# symmetry_crypto.py
from script.cryptohack.symmetry import *
from script.cryptohack.my_modulo import get_prime_factor
from script.cryptohack.elliptic_curve import pohlig_hellman
import primefac
import utils.socket_json_client as sjc
from sage.all import discrete_log, GF

def rsa_signature_example():
    N = 15216583654836731327639981224133918855895948374072384050848479908982286890731769486609085918857664046075375253168955058743185664390273058074450390236774324903305663479046566232967297765731625328029814055635316002591227570271271445226094919864475407884459980489638001092788574811554149774028950310695112688723853763743238753349782508121985338746755237819373178699343135091783992299561827389745132880022259873387524273298850340648779897909381979714026837172003953221052431217940632552930880000919436507245150726543040714721553361063311954285289857582079880295199632757829525723874753306371990452491305564061051059885803
    d = 11175901210643014262548222473449533091378848269490518850474399681690547281665059317155831692300453197335735728459259392366823302405685389586883670043744683993709123180805154631088513521456979317628012721881537154107239389466063136007337120599915456659758559300673444689263854921332185562706707573660658164991098457874495054854491474065039621922972671588299315846306069845169959451250821044417886630346229021305410340100401530146135418806544340908355106582089082980533651095594192031411679866134256418292249592135441145384466261279428795408721990564658703903787956958168449841491667690491585550160457893350536334242689
    message = b"crypto{Immut4ble_m3ssag1ng}"
    hashed_message = hashlib.sha256(message).digest()
    
    return pow(bytes_to_long(hashed_message), d, N)

def factoring_example():
    constant = 510143758735509025530880200653196460532653147 
    return primefac.multifactor(constant, verbose=True)

def monoprime():
    n = 171731371218065444125482536302245915415603318380280392385291836472299752747934607246477508507827284075763910264995326010251268493630501989810855418416643352631102434317900028697993224868629935657273062472544675693365930943308086634291936846505861203914449338007760990051788980485462592823446469606824421932591                                                                  
    e = 65537
    ct = 161367550346730604451454756189028938964941280347662098798775466019463375610700074840105776873791605070092554650190486030367121011578171525759600774739890458414593857709994072516290998135846956596662071379067305011746842247628316996977338024343628757374524136260758515864509435302781735938531030576289086798942  

    # We can easily calculate d where d * e mod phi_euler(n) = 1,
    # by extended euler algorithm,
    # since phi_euler(n) is easy to compute as n is prime
    # We want phi_euler(n) as hard as to compute as possible, hence two primes approaches
    phi_euler_n = n - 1
    d = extended_euclid_prime(e, phi_euler_n)
    
    msg: int = pow(ct, d, n)
    return bytes.fromhex(hex(msg)[2:].zfill(2))

def manyprime():
    n = 580642391898843192929563856870897799650883152718761762932292482252152591279871421569162037190419036435041797739880389529593674485555792234900969402019055601781662044515999210032698275981631376651117318677368742867687180140048715627160641771118040372573575479330830092989800730105573700557717146251860588802509310534792310748898504394966263819959963273509119791037525504422606634640173277598774814099540555569257179715908642917355365791447508751401889724095964924513196281345665480688029639999472649549163147599540142367575413885729653166517595719991872223011969856259344396899748662101941230745601719730556631637
    e = 65537
    ct = 320721490534624434149993723527322977960556510750628354856260732098109692581338409999983376131354918370047625150454728718467998870322344980985635149656977787964380651868131740312053755501594999166365821315043312308622388016666802478485476059625888033017198083472976011719998333985531756978678758897472845358167730221506573817798467100023754709109274265835201757369829744113233607359526441007577850111228850004361838028842815813724076511058179239339760639518034583306154826603816927757236549096339501503316601078891287408682099750164720032975016814187899399273719181407940397071512493967454225665490162619270814464
    # Here we use ECM (elliptic curve factorization method) to factorize n,
    # For the first few primes, this may take a while
    # Moral of the story is you should try to find hard-to-factor prime
    num_to_factor = n
    prime_list = []
    # Factorize n
    while (num_to_factor > 1):
        prime = primefac.ecm(num_to_factor)
        prime_list.append(prime)
        num_to_factor //= prime
        pprint(f"Prime found: {prime}!")
        
    pprint(f"Primes list: {prime_list}")    
    
    # calculate phi_euler(n)
    phi_euler_n = 1
    for prime in prime_list:
        phi_euler_n *= prime - 1
    # calculate d
    d = extended_euclid_prime(e, phi_euler_n)
    # get message
    msg: int = pow(ct, d, n)
    return bytes.fromhex(hex(msg)[2:].zfill(2))
    
def salty():
    n = 110581795715958566206600392161360212579669637391437097703685154237017351570464767725324182051199901920318211290404777259728923614917211291562555864753005179326101890427669819834642007924406862482343614488768256951616086287044725034412802176312273081322195866046098595306261781788276570920467840172004530873767                                                                  
    e = 1
    ct = 44981230718212183604274785925793145442655465025264554046028251311164494127485
    
    # msg ^ e = ct mod n
    # msg = ct mod n
    msg: int = pow(ct, 1, n)
    return bytes.fromhex(hex(msg)[2:].zfill(2))

def modulus_inutilis():
    n = 17258212916191948536348548470938004244269544560039009244721959293554822498047075403658429865201816363311805874117705688359853941515579440852166618074161313773416434156467811969628473425365608002907061241714688204565170146117869742910273064909154666642642308154422770994836108669814632309362483307560217924183202838588431342622551598499747369771295105890359290073146330677383341121242366368309126850094371525078749496850520075015636716490087482193603562501577348571256210991732071282478547626856068209192987351212490642903450263288650415552403935705444809043563866466823492258216747445926536608548665086042098252335883
    e = 3
    ct = 243251053617903760309941844835411292373350655973075480264001352919865180151222189820473358411037759381328642957324889519192337152355302808400638052620580409813222660643570085177957
    
    # when we calculate msg^e, we want the result to be larger than n,
    # so when we mod, it subtract the result by n, hiding the values.
    # otherwise, we can just find e-th root of ct and get a message 
    msg = nthroot_newtons(e, ct)
    return bytes.fromhex(hex(msg)[2:].zfill(2))

def working_with_fields():
    p=991
    g=209
    
    d = pow(g, p-2, p)
    return d

def generator_of_groups():
    p=28151 
    assert is_prime_naive(p)
    # Recap on primitive element of a set F
    # Set F: a set of every value for n mod p (that means 0 -> p -1)
    # Ring: by + or *, we can obtain some other element inside set F
    # Field: if p is prime, we can obtain *every* other element, as a^(k-1) mod p = 1 true for every a
    # Subgroup H: every element inside F_p can be made into a subgroup. For element g: H=⟨g⟩={g,g^2,g^3,…}
    # Primitive element of a set F: A subgroup H(g) that can be used to create every element inside F.
    # In another word, for every element a inside F: a = g^k mod p for certain integer k
    
    # A primitive element's subgroup has, by definition, p-1 elements inside it (we exclude 0)
    # Thus a generator g^k mod p must create a field of p-1 elements
    # So the smallest integer k such that g^k mod p = 1,
    # must be equal to p - 1 (in another word, there must k-1 element before returning to 1, 
    # since g^i = 1 means g^(i+1) = g, completing the ring)
    
    # So the problem is find primitive element g such that
    # it create subgroup H with the smallest int k
    # => From 1 to k=p-1, it must not form a sub-ring
    # => q^((p-1)/i) != 1 mod p for every i that is a factor of p-1, except for itself
    
    prime_factors = get_prime_factor(p-1)
    factor_combinations = get_combination_from_dict(prime_factors)
    exponents_to_check = set()
    
    for combination in factor_combinations:
        product = math.prod(combination)
        if product not in exponents_to_check and product != p-1:
            exponents_to_check.add(product)
    
    for ele in range(2, p):
        found_sub_ring = False
        for exp in exponents_to_check:
            # calculate factor
            if pow(ele, exp, p) == 1:
                found_sub_ring = True
                break
        if not found_sub_ring:
            return ele
    return None

def computing_public_value():
    g= 2
    p= 2410312426921032588552076022197566074856950548502459942654116941958108831682612228890093858261341614673227141477904012196503648957050582631942730706805009223062734745341073406696246014589361659774041027169249453200378729434170325843778659198143763193776859869524088940195577346119843545301547043747207749969763750084308926339295559968882457872412993810129130294592999947926365264059284647209730384947211681434464714438488520940127459844288859336526896320919633919 
    a= 972107443837033796245864316200458246846904598488981605856765890478853088246897345487328491037710219222038930943365848626194109830309179393018216763327572120124760140018038673999837643377590434413866611132403979547150659053897355593394492586978400044375465657296027592948349589216415363722668361328689588996541370097559090335137676411595949335857341797148926151694299575970292809805314431447043469447485957669949989090202320234337890323293401862304986599884732815 

    return pow(g,a,p)

def computing_shared_secret():
    g= 2
    p= 2410312426921032588552076022197566074856950548502459942654116941958108831682612228890093858261341614673227141477904012196503648957050582631942730706805009223062734745341073406696246014589361659774041027169249453200378729434170325843778659198143763193776859869524088940195577346119843545301547043747207749969763750084308926339295559968882457872412993810129130294592999947926365264059284647209730384947211681434464714438488520940127459844288859336526896320919633919 
    
    A= 70249943217595468278554541264975482909289174351516133994495821400710625291840101960595720462672604202133493023241393916394629829526272643847352371534839862030410331485087487331809285533195024369287293217083414424096866925845838641840923193480821332056735592483730921055532222505605661664236182285229504265881752580410194731633895345823963910901731715743835775619780738974844840425579683385344491015955892106904647602049559477279345982530488299847663103078045601 
    b= 12019233252903990344598522535774963020395770409445296724034378433497976840167805970589960962221948290951873387728102115996831454482299243226839490999713763440412177965861508773420532266484619126710566414914227560103715336696193210379850575047730388378348266180934946139100479831339835896583443691529372703954589071507717917136906770122077739814262298488662138085608736103418601750861698417340264213867753834679359191427098195887112064503104510489610448294420720
    B= 518386956790041579928056815914221837599234551655144585133414727838977145777213383018096662516814302583841858901021822273505120728451788412967971809038854090670743265187138208169355155411883063541881209288967735684152473260687799664130956969450297407027926009182761627800181901721840557870828019840218548188487260441829333603432714023447029942863076979487889569452186257333512355724725941390498966546682790608125613166744820307691068563387354936732643569654017172
    assert pow(g,b,p) == B
    
    return pow(A, b, p)

def deriving_symmetric_key():
    g= 2
    p= 2410312426921032588552076022197566074856950548502459942654116941958108831682612228890093858261341614673227141477904012196503648957050582631942730706805009223062734745341073406696246014589361659774041027169249453200378729434170325843778659198143763193776859869524088940195577346119843545301547043747207749969763750084308926339295559968882457872412993810129130294592999947926365264059284647209730384947211681434464714438488520940127459844288859336526896320919633919 
    
    A= 112218739139542908880564359534373424013016249772931962692237907571990334483528877513809272625610512061159061737608547288558662879685086684299624481742865016924065000555267977830144740364467977206555914781236397216033805882207640219686011643468275165718132888489024688846101943642459655423609111976363316080620471928236879737944217503462265615774774318986375878440978819238346077908864116156831874695817477772477121232820827728424890845769152726027520772901423784 
    b= 197395083814907028991785772714920885908249341925650951555219049411298436217190605190824934787336279228785809783531814507661385111220639329358048196339626065676869119737979175531770768861808581110311903548567424039264485661330995221907803300824165469977099494284722831845653985392791480264712091293580274947132480402319812110462641143884577706335859190668240694680261160210609506891842793868297672619625924001403035676872189455767944077542198064499486164431451944 
    B= 1241972460522075344783337556660700537760331108332735677863862813666578639518899293226399921252049655031563612905395145236854443334774555982204857895716383215705498970395379526698761468932147200650513626028263449605755661189525521343142979265044068409405667549241125597387173006460145379759986272191990675988873894208956851773331039747840312455221354589910726982819203421992729738296452820365553759182547255998984882158393688119629609067647494762616719047466973581
    assert pow(g,b,p) == B
    
    shared_secret = pow(A, b, p)
    iv = '737561146ff8194f45290f5766ed6aba'
    encrypted_flag='39c99bf2f0c14678d6a5416faef954b5893c316fc3c48622ba1fd6a9fe85f3dc72a29c394cf4bc8aff6a7b21cae8e12c'
    
    return decrypt_flag(shared_secret, iv, encrypted_flag)

def parameter_injection():
    host = "socket.cryptohack.org"
    port = 13371
    
    tube = sjc.remote(host, str(port))
    print(f"Connecting to {host}:{port} ...")
    
    # sjc.read_banner_lines(tube, 1)
    
    # Alice keys
    s = tube.recvline()
    print(s)
    s = s.decode()
    alice_response = eval(s[s.find('{'):])
    assert isinstance(alice_response, dict)
    
    p = int(alice_response["p"], 16)
    g = int(alice_response["g"], 16)
    A = int(alice_response["A"], 16)
    
    # Here we will pretend to be Alice and generate a small private key in place of her
    mA = 3 # You can use random values
    MA = pow(g, mA, p)
    request = {
        'p': alice_response["p"],
        'g': alice_response["g"],
        'A': hex(MA)
    }
    sjc.json_send(tube, request)
    s = tube.recvline()
    print(s)
    
    s = s.decode()
    bob_response = eval(s[s.find('{'):])
    assert isinstance(bob_response, dict)

    # We do the same for Bob
    B = int(bob_response['B'], 16)
    mB = 4
    MB = pow(g, mB, p)
    request = {
        'p': alice_response["p"],
        'g': alice_response["g"],
        'B': hex(MB)
    }
    sjc.json_send(tube, request)
    s = tube.recvline()
    print(s)
    
    s = s.decode()
    flag_response = eval(s[s.find('{'):])
    assert isinstance(flag_response, dict)
    
    # Now we've fooled Alice into accepting our public key instead of Bob's, we arrive the same shared_secret with Alice
    iv = flag_response["iv"]
    encrypted_flag = flag_response["encrypted_flag"]
    
    shared_secret = pow(A, mB, p)
    flag = decrypt_flag(shared_secret, iv, encrypted_flag)
    
    tube.close()
    return flag


def export_grade():
    host = "socket.cryptohack.org"
    port = 13379
    
    tube = sjc.remote(host, str(port))
    print(f"Connecting to {host}:{port} ...")
    
    # sjc.read_banner_lines(tube, 1)
    
    def send(r, req:dict):
        try:
            sjc.json_send(r, req)
        except Exception as e:
            return f"Error: {e}"
        return "Ok"
    
    def recv(r):
        s = r.recvline()
        print(s)
        
        s = s.decode()
        response = eval(s[s.find('{'):])
        assert isinstance(response, dict)
        return response
    
    # Alice keys
    alice_response = recv(tube)
    supported_format = alice_response["supported"][-1] # Here we will choose DH64 for the easiest format to attack
    # Now we send it to Bob
    request = {
        'supported': [supported_format],
    }
    send(tube, request)
    bob_response = recv(tube)
    # Reply to Alice
    request = {
        'chosen': supported_format 
    }
    send(tube, request)
    alice_response = recv(tube)
    
    p = int(alice_response["p"], 16)
    g = int(alice_response["g"], 16)
    A = int(alice_response["A"], 16)

    # We can find Alice private keys by a DLP algorithm
    # Since the search space is 2^32 in average
    # While we no longer can pretend as Bob,
    # We can still derive their private key from unsafe protocol
    a = pohlig_hellman(g, A, p)
    assert a is not None
    # Send to Bob
    request = {
        'p': hex(p),
        'g': hex(g),
        'A': hex(A)
    }
    send(tube, request)
    bob_response = recv(tube)
    
    B = int(bob_response["B"], 16)
    b = pohlig_hellman(g, B, p)
    assert b is not None
    # Get flag
    request = {
        'p': hex(p),
        'g': hex(g),
        'B': hex(B)
    }
    send(tube, request)
    flag_response = recv(tube)
    
    iv = flag_response['iv']
    encrypted_flag = flag_response['encrypted_flag']
    
    tube.close()
    shared_secret = pow(A, b, p)
    
    flag = decrypt_flag(shared_secret, iv, encrypted_flag)
    return flag

def main():
    print("Usage: python -c 'from solution.symmetry_solution import *; print(<function>())'")
    
if __name__ == "__main__":
    main()